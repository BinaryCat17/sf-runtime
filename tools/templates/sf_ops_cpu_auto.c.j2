#include <sionflow/ops/sf_ops_core.h>
#include "sf_kernel_utils.h"
#include <sionflow/isa/sf_opcodes.h>
#include <sionflow/base/sf_math.h>
#include <sionflow/isa/sf_exec_ctx.h>
#include "sf_ops_internal.h"
#include <math.h>

/**
 * SionFlow CPU Kernels (Auto-generated)
 * Automatically generated from isa.json and cpu_spec.json. DO NOT EDIT.
 */

{% for node_id, impl in implementations.items() %}
{% set node = nodes_by_id[node_id] %}
{% if node and impl.expression %}
void op_{{ node.opcode }}(sf_exec_ctx* ctx, const struct sf_instruction* inst) {
    const size_t sz = ctx->batch_size;
    u8* d_ptr = (u8*)ctx->reg_ptrs[inst->dest_idx];
    u8* a_ptr = (u8*)ctx->reg_ptrs[inst->src1_idx];
    {% if node.inputs|length >= 2 %}u8* b_ptr = (u8*)ctx->reg_ptrs[inst->src2_idx];{% endif %}
    {% if node.inputs|length >= 3 %}u8* c_ptr = (u8*)ctx->reg_ptrs[inst->src3_idx];{% endif %}
    
    const i32 st0 = SF_GET_STRIDE_D(inst);
    const i32 st1 = SF_GET_STRIDE_S1(inst);
    {% if node.inputs|length >= 2 %}const i32 st2 = SF_GET_STRIDE_S2(inst);{% endif %}
    {% if node.inputs|length >= 3 %}const i32 st3 = SF_GET_STRIDE_S3(inst);{% endif %}
    
    for(size_t i=0; i<sz; ++i) {
        const f32 va = *(f32*)a_ptr;
        {% if node.inputs|length >= 2 %}const f32 vb = *(f32*)b_ptr;{% endif %}
        {% if node.inputs|length >= 3 %}const f32 vc = *(f32*)c_ptr;{% endif %}
        
        *(f32*)d_ptr = SF_SAFE_F32({{ impl.expression }});
        
        a_ptr += st1;
        {% if node.inputs|length >= 2 %}b_ptr += st2;{% endif %}
        {% if node.inputs|length >= 3 %}c_ptr += st3;{% endif %}
        d_ptr += st0;
    }
}
{% endif %}
{% endfor %}
